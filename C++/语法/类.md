[TOC]

使用关键字**class**、**struct**、**union**来声明和定义一个类。

> union：联合

# 成员

类的成员包括数据成员、成员函数、类型成员。

对于成员函数，以下函数如果没有主动定义，编译器将提供一个合成版本：

- 默认构造函数
- 拷贝构造函数
- 赋值
- 析构函数

## 构造函数

构造函数（constructor）用来初始化类对象的数据成员，无论何时类的对象被创建，就会执行构造函数。构造函数有以下特点：

- 构造函数名与类名相同
- 构造函数没有返回值
- 构造函数参数可以为空，也可以不为空
- 可以有多个构造函数，类似于重载函数，不同的构造函数之间必须在参数个数或参数类型上有所区别

### 默认构造函数

没有任何参数的构造函数。其初始化类的数据成员的规则如下：

- 如果存在类内的初始值，用它来初始化成员
- 否则，默认初始化该成员

如果一个类没有显式的定义构造函数，那么编译器将会隐式的定义一个默认构造函数，被称为合成的默认构造函数。但如果一个类定义了构造函数（即使没有定义默认构造函数），编译器就不会自动地生成默认构造函数，在此种情况下，如果我们仍然需要一个默认构造函数，可以使用**default**关键字来指定：

```c++
class A
{
public:
    //定义我们自己的构造函数，编译器不会自动生成默认构造函数
    A(int i);
    //使用default要求编译器生成一个默认构造函数
    A() = default;
};
```

### 拷贝构造函数

如果一个构造函数的第一个参数时自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

### 转换构造函数

只接受一个实参的构造函数，在定义了此种构造函数的情况下，实际上定义了从实参类型到此类型的隐式转换机制。例如：

```c++
class A
{
public:
    A() = default;
    //转换构造函数：实际定义了从int向类A的隐式转换机制
    A(int i);
}

int n = 0;

//正确，拷贝形式的初始化
A a = n;
```

如果不允许此种隐式转换的发生，可以使用**explicit**关键字：

```c++
class A
{
public:
    A() = default;
    //抑制了隐式转换
    explicit A(int i);
}

int n = 0;

//错误，不允许此种类型的拷贝形式的初始化
A a = n;
//正确，直接初始化的形式
A a(n);
```

## 析构函数

析构函数（ destructor）用来销毁对象。析构函数有以下特点：

- 析构函数名为字符'~'加上类名
- 析构函数没有返回值
- 析构函数无参
- 一个类只有一个析构函数

如果我们没有主动提供析构函数，编译器将自动提供一个合成版本。但可以使用**default**关键字显式指定编译器提供一个合成的析构函数：

```c++
class A
{
public:
    ~A() = default;
};
```

> 当类需要分配类对象之外的资源时，不能依赖合成版本的析构函数

# 访问控制

| 访问说明符 | 描述                         |
| ---------- | ---------------------------- |
| public     | 在整个程序内可被访问         |
| protected  | 类的成员函数和派生类可以访问 |
| private    | 类的成员函数可以访问         |

> class默认的访问控制为private；struct默认的访问控制为public